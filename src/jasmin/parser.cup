/** 
    Modifications Copyright (C) 1997, 1998 Raja Vallee-Rai (kor@sable.mcgill.ca)
    All rights reserved.                                              
   
    Changes:
        - Changed the grammar of the parser to fix some ambiguities
          which occur when a field is named "method" and vice versa.                                                                  
*/

/* --- Copyright Jonathan Meyer 1996. All rights reserved. -----------------
 > File:        jasmin/src/jasmin/parser.cup
 > Purpose:     Parser for Jasmin
 > Author:      Jonathan Meyer, 10 July 1996
 */

/*
 * parser.cup - Java CUP file containing LALR(1) grammar for Jasmin,
 * along with calls to ClassFile methods to output bytecode.
 */

/* CHANGES
 * soot.tagkits.Base64 is changed to Base64 from jas package. 
 *
 * Feng Qian, Jan 25, 2001
 */

package jasmin;

import java_cup.runtime.*;
import jas.*;
import java.io.*;
import java.util.Hashtable;

/* Preliminaries to set up and use the scanner.  */

action code {:
    short access_val;
    public Scanner scanner;
    public ClassFile classFile;
:};

parser code {:

	// parser code

	public Scanner scanner;
	public ClassFile classFile;
	
	public void report_error(String message, Object info)  {
    	classFile.report_error("Warning - " + message);
	}

	public void report_fatal_error(String message, Object info)  {
    	classFile.report_error("Error - " + message);
    	// System.exit(-1);
	}

	parser(ClassFile classFile, Scanner scanner) {
	    super();

	    this.scanner = scanner;
	    this.classFile = classFile;
	}
:};

init with {:
	action_obj.scanner = scanner;
	action_obj.classFile = classFile;
:};

scan with {:
    return scanner.next_token();
:};



/* Terminals (tokens returned by the scanner). */
terminal token
    // Directives (words beginning with a '.')
    DCATCH, DCLASS, DEND, DFIELD, DLIMIT, DLINE, DMETHOD, DSET, DSUPER,
    DSOURCE, DTHROWS, DVAR, DIMPLEMENTS, DINTERFACE,

   // Attributes
	DCODE_ATTR, DCLASS_ATTR, DFIELD_ATTR, DMETHOD_ATTR,


    // keywords for directives
    TO, USING, IS, FROM, METHOD,

    // access types
    ABSTRACT, FINAL, INTERFACE, NATIVE, PRIVATE, PROTECTED, PUBLIC, STATIC,
    SYNCHRONIZED, TRANSIENT, VOLATILE,

    // complex instructions
    LOOKUPSWITCH, TABLESWITCH, DEFAULT,

    // special symbols
    EQ, SEP, COLON
 ;

terminal String Str, Word, Insn;
terminal Integer Int;
terminal Number Num;

nonterminal String classname;
nonterminal Object optional_default, item;

/* Non terminals */
nonterminal 
       access_item, access_items, access_list, catch_expr, class_spec,
       complex_instruction, defmethod, directive, endmethod, field_list,
       field_spec, fields, instruction, implements, implements_list, implements_spec,
       jas_file, label, limit_expr, lookup,
       lookup_args, lookup_default, lookup_entry, lookup_list_t, lookup_list, method_list,
       method_spec, methods, set_expr, simple_instruction, source_spec,
       statement, statements, stmnt, super_spec, table, table_args, line_expr,
       table_default, table_entry, table_list_t, table_list, throws_expr, var_expr, 
	   code_attr_expr, 
	   class_attrs, class_attr_list,  class_attr_spec,
	   method_item, method_attrs, method_attr_list,  method_attr_spec,
	   field_item, field_attrs, field_attr_list,  field_attr_spec	
    ;

nonterminal Short access;

/* The grammar */

jas_file ::=
        source_spec        
        class_spec
        super_spec
	implements
	class_attrs	
        fields
        methods
    ;

// ---- Source specification

source_spec ::=
    DSOURCE Word:w SEP
        {: classFile.setSource(w); :}
    |
    /* nothing */
;

// ---- Class specification

class_spec ::=
    DCLASS access:a classname:name SEP
        {:
            classFile.setClass(name,
                (short)(a.intValue() | RuntimeConstants.ACC_SUPER));
        :}
    |
    DINTERFACE access:a classname:name SEP
        {:
            classFile.setClass(name,
                (short)(a.intValue() |
                        RuntimeConstants.ACC_SUPER |
                        RuntimeConstants.ACC_INTERFACE));
        :}
  ;

classname ::=
    Word:w
        {: RESULT = ScannerUtils.convertDots(w); :}

  ;

access ::=
    {: access_val = 0; :}
        access_list
    {: RESULT = new Short(access_val); :}
 ;


access_list ::= access_items | ;
access_items ::= access_items access_item | access_item ;

access_item ::=
    PUBLIC       {: access_val |= RuntimeConstants.ACC_PUBLIC; :}
    |
    PRIVATE      {: access_val |= RuntimeConstants.ACC_PRIVATE; :}
    |
    PROTECTED    {: access_val |= RuntimeConstants.ACC_PROTECTED; :}
    |
    STATIC       {: access_val |= RuntimeConstants.ACC_STATIC; :}
    |
    FINAL        {: access_val |= RuntimeConstants.ACC_FINAL; :}
    |
    SYNCHRONIZED {: access_val |= RuntimeConstants.ACC_SYNCHRONIZED; :}
    |
    VOLATILE     {: access_val |= RuntimeConstants.ACC_VOLATILE; :}
    |
    TRANSIENT    {: access_val |= RuntimeConstants.ACC_TRANSIENT; :}
    |
    NATIVE       {: access_val |= RuntimeConstants.ACC_NATIVE; :}
    |
    INTERFACE    {: access_val |= RuntimeConstants.ACC_INTERFACE; :}
    |
    ABSTRACT     {: access_val |= RuntimeConstants.ACC_ABSTRACT; :}
  ;

// ---- Superclass specification

super_spec ::=
    DSUPER classname:name SEP
        {:
            classFile.setSuperClass(name);
        :}
  ;

// ---- Implements specification

implements ::= implements_list | /* empty */ ;

implements_list ::= implements_list implements_spec | implements_spec ;

implements_spec ::= DIMPLEMENTS classname:name SEP
	{: classFile.addInterface(name); :}
    ;



// ---- Fields

fields ::= field_list | /* empty */ ;

field_list ::= field_list field_item | field_item;

field_item ::= field_spec field_attrs | field_spec;

field_spec ::=
    DFIELD access:a Str:name Word:sig optional_default:v SEP
        {:
            classFile.addField((short)a.intValue(), name, sig,
                            v);
        :}
   ;

// default value for a field
optional_default ::=
     EQ item:v   {: RESULT = v; :}
     |
     /* empty */ {: RESULT = null; :}
  ;

// an item is an integer, a float/double/long, or a quoted string
item ::=
    Int:i {: RESULT = i; :}
    |
    Num:n {: RESULT = n; :}
    |
    Str:s {: RESULT = s; :}
  ;

// ---- Methods

methods ::= method_list | /* empty */;

method_list ::= method_list method_item | method_item;

method_item ::= method_spec method_attrs | method_spec;

method_spec ::=
    defmethod
    statements
    endmethod
    |
    defmethod endmethod
 ;

defmethod ::=
    DMETHOD access:i Word:name SEP
        {:
            String split[] = ScannerUtils.splitMethodSignature(name);
            classFile.newMethod(split[0], split[1], i.intValue());
        :}
  ;

endmethod ::=
    DEND METHOD SEP
        {:
            classFile.endMethod();
        :}
  ;


// ---- Statements in a method

statements ::= statements statement | statement ;

statement ::=
     {: classFile.setLine(scanner.token_line_num); :}
     stmnt SEP
  ;

stmnt ::=
    instruction
    |
    directive
    |
    error
    |
    label
    |
    /* empty */
  ;

// label:
label ::=
    Word:label COLON
        {:
            classFile.plantLabel(label);
        :}
  ;

// Directives (.catch, .set, .limit, etc.)

directive ::=
    DVAR var_expr
    |
    DLIMIT limit_expr
    |
    DLINE line_expr
    |
    DTHROWS throws_expr
    |
    DCATCH catch_expr
    |
    DSET set_expr
    |
    DCODE_ATTR code_attr_expr   
  ;



code_attr_expr ::=
 Word:w Str:v
          {:
               classFile.addSootCodeAttr(w, v);    
          :}
;






//
// .var <num> is <name> <sig> from StartLab to EndLab
//
var_expr ::=
    Int:reg IS Word:name Word:sig FROM Word:slab TO Word:elab
        {:
             classFile.addVar(slab, elab, name,
                            sig, reg.intValue());
        :}
    |
    Int:reg IS Word:name Word:sig
        {:
             classFile.addVar(null, null, name, sig, reg.intValue());
        :}
;


// .limit stack <val>
// .limit locals <val>

limit_expr ::=
    Word:w Int:v
      {:
        // .limit locals
        if (w.equals("locals")
                 || w.equals("vars")) // "vars" for historic reasons
            classFile.setVarSize((short)v.intValue());
        // .limit stack
        else if (w.equals("stack"))
            classFile.setStackSize((short)v.intValue());
        else
            classFile.report_error(".limit expected \"stack\" or \"locals\", but got "
                          + w);
      :}
;

// .line <num>
line_expr ::=
    Int:v
       {: classFile.addLine(v.intValue()); :}
;

// .throws <class>
throws_expr ::=
    classname:s
        {:
            classFile.addThrow(s);
        :}
  ;

// .catch <class> from <label1> to <label2> using <branchlab>
catch_expr ::=
    classname:aclass FROM Word:fromlab TO Word:tolab USING Word:branchlab
        {:
            classFile.addCatch(aclass,
                            fromlab, tolab,
                            branchlab);
        :}
  ;

// .set <var> = <val>
set_expr ::=
    Word:name Int:v     {: scanner.dict.put(name, v); :}
    |
    Word:name Word:v    {: scanner.dict.put(name, v); :}
    |
    Word:name Num:v  {: scanner.dict.put(name, v); :}
    |
    Word:name Str:v  {: scanner.dict.put(name, v); :}
;

instruction ::=
    simple_instruction
    |
    complex_instruction
 ;

// Various patterns of instruction:
//      instruction [<pattern>]
simple_instruction ::=
    Insn:i
        {:
            classFile.plant(i);
        :}
    |
    Insn:i Int:n1 Int:n2
        {:
            classFile.plant(i, n1.intValue(), n2.intValue());
        :}
    |
    Insn:i Int:n
        {:
            classFile.plant(i, n.intValue());
        :}
    |
    Insn:i Num:n
        {:
            classFile.plant(i, n);
        :}
    |
    Insn:i Word:n
        {:
            classFile.plant(i, n);
        :}
    |
    Insn:i Word:n Int:n2
        {:
            classFile.plant(i, n, n2.intValue());
        :}
    |
    Insn:i Word:n1 Word:n2
        {:
            classFile.plant(i, n1, n2);
        :}
    |
    Insn:i Str:n
        {:
            classFile.plantString(i, n);
        :}
  ;

// complex (i.e. multiline) instructions
//      lookupswitch <lookup>
//      tableswitch  <table>

complex_instruction ::=
    LOOKUPSWITCH lookup
    |
    TABLESWITCH table
 ;

// lookupswitch
//     <value> : <label>
//     <value> : <label>
//     ...
//     default : <label>

lookup ::=
    lookup_args
    lookup_list_t
    lookup_default
  ;

lookup_args ::=
    SEP         /* no arguments to lookupswitch */
        {: classFile.newLookupswitch(); :}
  ;

lookup_list_t ::=
     | lookup_list
  ;

lookup_list ::=
    lookup_list lookup_entry | lookup_entry 
 ;

lookup_entry ::=
    Int:i COLON Word:w SEP
        {:
            classFile.addLookupswitch(i.intValue(), w);
        :}
  ;

lookup_default ::=
    DEFAULT COLON Word:w
        {: classFile.endLookupswitch(w); :}
  ;


// tableswitch <low> [<high>]
//     <label>
//     <label>
//     ...
//     default : <label>

table ::=
    table_args
    table_list_t
    table_default
  ;

table_args ::=
    Int:low SEP     /* one argument : the <low> parameter */
        {:
            classFile.newTableswitch(low.intValue());
        :}
    |
    Int:low Int:high SEP     /* two arguments : <low> and <high> parameters */
        {:
            classFile.newTableswitch(low.intValue(), high.intValue());
        :}
  ;

table_list_t ::=
     | table_list
	;

table_list ::=
    table_list table_entry | table_entry 
  ;

table_entry ::=
    Word:w SEP
        {:
            classFile.addTableswitch(w);
        :}
  ;

table_default ::=
    DEFAULT COLON Word:w
        {:
            classFile.endTableswitch(w);
        :}
  ;




class_attrs ::= class_attr_list | /* */;
class_attr_list ::= class_attr_list class_attr_spec | class_attr_spec;
class_attr_spec ::= DCLASS_ATTR  Word:w Str:v SEP
          {:
		byte[] data = Base64.decode(v.toCharArray());
                classFile.addGenericAttrToClass(new GenericAttr(w, data));             
          :}
;
	
method_attrs ::= method_attr_list; 
method_attr_list ::= method_attr_list method_attr_spec | method_attr_spec;
method_attr_spec ::= DMETHOD_ATTR  Word:w Str:v SEP
          {:
		 byte[] data = Base64.decode(v.toCharArray());
                classFile.addGenericAttrToMethod(w, data);	
          :}
;

	
field_attrs ::= field_attr_list; 
field_attr_list ::= field_attr_list field_attr_spec | field_attr_spec;
field_attr_spec ::= DFIELD_ATTR  Word:w Str:v SEP
          {:
		 byte[] data = Base64.decode(v.toCharArray());
                classFile.addGenericAttrToField(w, data);
          :}
;





/* --- Revision History ---------------------------------------------------
--- Jonathan Meyer, Mar 1 1997
    Added ACC_SUPER flag - needed by 1.1.

--- Jonathan Meyer, Oct 1 1996
    Added support for .interface and .implements.

--- Jonathan Meyer, July 25 1996
    Slightly modified syntax of .var directive.

    Added call to setLine to fix problem with line numbering.

    Added definitions for report_error and report_fatal_error, and
    also added 'error' token to statements list.
*/
